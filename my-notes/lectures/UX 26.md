## 1. What the Software Development Process Is

* A **structured approach** to building, deploying, and maintaining software.
* Applies to **software, hardware, systems engineering, and information systems**.
* Necessary for **large or complex projects** to avoid failure.
* Follows a **life cycle** from idea → development → maintenance → retirement.

---

## 2. Why Planning Is Non-Negotiable

* Skipping planning leads to:

  * Scope confusion
  * Budget overruns
  * Poor quality
  * Project failure
* Planning enables:

  * Strategic decision-making
  * Correct prioritization
  * Risk management
  * Controlled change handling

---

## 3. Core Reasons for Planning a Software Project

1. **Define goals**
2. **Determine requirements**
3. **Estimate costs**
4. **Create timelines**
5. **Improve software quality**
6. **Understand project value**

---

## 4. Goal Definition

* Transforms vague ideas into **clear, realistic objectives**
* Unrealistic goals significantly increase failure risk
* Goals must be **measurable and achievable**

---

## 5. Requirements Determination

* Identifies everything needed to build the software:

  * Team
  * Skills
  * Hardware/software
  * User input
  * Budget
* Requirements often **change during development**
* Without planning, changes cause chaos and overspending

---

## 6. Cost Planning

* Determines:

  * Development cost
  * Operational cost
  * Return on investment
* Prevents waste and financial failure
* Closely tied to **scope definition**

---

## 7. Timeline Creation

* Establishes:

  * Milestones
  * Deadlines
  * Deliverables
* Essential for multi-person projects
* Software is never “perfect”; timely release matters

---

## 8. Quality and Risk Control

* Planning provides:

  * Benchmarks for quality
  * Metrics for evaluation
* Deviations are allowed but must be **controlled**
* Enables handling unexpected issues without panic

---

## 9. Understanding Project Value

* Value is evaluated continuously using:

  * Milestones
  * Deliverables
  * Cost vs benefit
* Helps decide whether to continue, pivot, or terminate a project

---

## 10. Software Development Life Cycle (SDLC)

Standard stages followed by most methodologies:

1. Analysis
2. Feasibility Study
3. Design
4. Coding
5. Testing
6. Deployment
7. Maintenance

---

## 11. Analysis Stage

Purpose: **Decide whether the project is worth doing**

Key activities:

* Gather user requirements
* Identify users, inputs, outputs, environment
* Define objectives
* Identify available resources
* Analyze competitors (if applicable)

Sub-steps:

1. Requirements gathering
2. Scope definition
3. Risk, cost, and quality planning

---

## 12. Scope Definition

* Defines **upper and lower limits** of the solution
* Prevents infinite expansion of features
* Balances:

  * User needs
  * Time
  * Budget
  * Resources

---

## 13. Feasibility Study

Determines whether the project is **practical and viable**

Produces: **Software Requirements Specification (SRS)**

### Five Feasibility Aspects

1. **Technical** – Can existing systems handle it?
2. **Economic** – Is it financially viable?
3. **Legal** – Is it legally compliant?
4. **Operational** – Can it be operated and maintained?
5. **Schedule** – Can it be completed on time?

Failure here usually guarantees project failure later.

---

## 14. Design Phase

Produces two documents:

### 14.1 High-Level Design (HLD)

* Module overview
* Module interactions
* System architecture
* Technology stack
* Database identification

### 14.2 Low-Level Design (LLD)

* Detailed logic
* Data structures
* Database schemas
* UI details
* Error handling
* Input/output mapping

These documents guide coding and testing.

---

## 15. Coding Phase

* Actual implementation of the system
* Developers follow HLD and LLD
* Modules assigned to teams
* Longest phase of the life cycle
* Language and tools already chosen

---

## 16. Testing Phase

Ensures correctness and quality.

### Testing Types

* **Black-box testing**

  * Tests external behavior
  * Focuses on user experience

* **White-box testing**

  * Tests internal logic
  * Focuses on correctness and structure

Goal: eliminate as many bugs as possible before release.

---

## 17. Deployment Phase

* Software installed in real environment
* Pilot testing performed
* Final commissioning after user approval
* Some bugs may appear only after deployment

---

## 18. Maintenance Phase

Continues for the rest of the software’s life.

### Types of Maintenance

1. **Preventive**

   * Bug fixes
   * OS compatibility updates
   * Performance optimization

2. **Perfective**

   * New features
   * Enhancements based on feedback

3. **Adaptive**

   * Internal improvements
   * UI updates
   * Technology upgrades

---

## 19. Major SDLC Models

### 19.1 Waterfall Model

* Linear, sequential stages
* Each phase must finish before next begins

**Best suited for:**

* Small projects
* Stable requirements
* Fixed scope

**Advantages**

* Simple and structured
* Well-documented
* Easy task distribution

**Disadvantages**

* Late visibility of working software
* Poor at handling changes
* High risk for complex projects

---

### 19.2 V-Model

* Extension of waterfall
* Each development phase has a corresponding testing phase

Testing stages:

1. Unit testing
2. Integration testing
3. System testing
4. Acceptance testing

Same strengths and weaknesses as waterfall, with better testing alignment.

---

### 19.3 Iterative Model

* Software built in **small increments**
* Each iteration delivers working functionality

**Advantages**

* Early usable product
* Supports parallel work
* Lower cost of changes

**Disadvantages**

* Requires strong management
* Less detailed initial requirements
* Not ideal for small projects

---

### 19.4 Spiral Model

* Combines iterative development with risk analysis
* Heavy focus on customer feedback

**Best suited for:**

* High-risk projects
* Changing requirements
* Tight budgets

**Disadvantages**

* Complex management
* High documentation overhead
* Not suitable for low-risk projects

---

## 20. Agile Development

* Based on **iterative and incremental delivery**
* Emphasizes:

  * Customer collaboration
  * Rapid delivery
  * Continuous improvement

Used in frameworks like:

* Scrum
* Kanban
* Extreme Programming (XP)
* Feature-Driven Development

---

## 21. Agile vs Waterfall (Key Differences)

* Agile is flexible; waterfall is rigid
* Agile delivers early and often; waterfall delivers late
* Agile embraces change; waterfall resists it
* Agile prioritizes working software; waterfall prioritizes documentation
* Agile integrates testing continuously; waterfall tests late

---

## 22. Seven Root Causes of Project Failure

1. **Obscurity** – Unclear goals
2. **Insentience** – Incompetent leadership
3. **Tardiness** – Missed deadlines
4. **Lethargy** – Lack of urgency
5. **Inevitability** – Ignoring risk
6. **Obsequiousness** – Poor authority and scope creep
7. **Evolution** – Uncontrolled change

---

## 23. All Things to Remember

* SDLC stages are universal across methodologies
* Planning saves time, money, and effort
* Scope control is critical
* Feasibility determines success early
* Design documents guide everything downstream
* Testing is continuous, not optional
* Maintenance dominates software lifespan
* Agile fits modern, fast-changing environments
* Poor planning is the primary cause of failure

---
